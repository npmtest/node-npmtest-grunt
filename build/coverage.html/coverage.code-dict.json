{"/home/travis/build/npmtest/node-npmtest-grunt/test.js":"/* istanbul instrument in package npmtest_grunt */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-grunt/lib.npmtest_grunt.js":"/* istanbul instrument in package npmtest_grunt */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_grunt = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_grunt = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-grunt/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-grunt && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_grunt */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_grunt\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught.stack);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_grunt.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        local.assetsDict['/assets.npmtest_grunt.rollup.js'] =\n            local.assetsDict['/assets.npmtest_grunt.rollup.js'] ||\n            local.fs.readFileSync(\n                // buildCustomOrg-hack\n                local.npmtest_grunt.__dirname +\n                    '/lib.npmtest_grunt.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-grunt/grunt/lib/grunt.js":"'use strict';\n\n// Nodejs libs.\nvar path = require('path');\n\n// This allows grunt to require() .coffee files.\nrequire('coffee-script/register');\n\n// The module to be exported.\nvar grunt = module.exports = {};\n\n// Expose internal grunt libs.\nfunction gRequire(name) {\n  return grunt[name] = require('./grunt/' + name);\n}\n\nvar util = require('grunt-legacy-util');\ngrunt.util = util;\ngrunt.util.task = require('./util/task');\n\nvar Log = require('grunt-legacy-log').Log;\nvar log = new Log({grunt: grunt});\ngrunt.log = log;\n\ngRequire('template');\ngRequire('event');\nvar fail = gRequire('fail');\ngRequire('file');\nvar option = gRequire('option');\nvar config = gRequire('config');\nvar task = gRequire('task');\nvar help = gRequire('help');\ngRequire('cli');\nvar verbose = grunt.verbose = log.verbose;\n\n// Expose some grunt metadata.\ngrunt.package = require('../package.json');\ngrunt.version = grunt.package.version;\n\n// Expose specific grunt lib methods on grunt.\nfunction gExpose(obj, methodName, newMethodName) {\n  grunt[newMethodName || methodName] = obj[methodName].bind(obj);\n}\ngExpose(task, 'registerTask');\ngExpose(task, 'registerMultiTask');\ngExpose(task, 'registerInitTask');\ngExpose(task, 'renameTask');\ngExpose(task, 'loadTasks');\ngExpose(task, 'loadNpmTasks');\ngExpose(config, 'init', 'initConfig');\ngExpose(fail, 'warn');\ngExpose(fail, 'fatal');\n\n// Expose the task interface. I've never called this manually, and have no idea\n// how it will work. But it might.\ngrunt.tasks = function(tasks, options, done) {\n  // Update options with passed-in options.\n  option.init(options);\n\n  // Display the grunt version and quit if the user did --version.\n  var _tasks, _options;\n  if (option('version')) {\n    // Not --verbose.\n    log.writeln('grunt v' + grunt.version);\n\n    if (option('verbose')) {\n      // --verbose\n      verbose.writeln('Install path: ' + path.resolve(__dirname, '..'));\n      // Yes, this is a total hack, but we don't want to log all that verbose\n      // task initialization stuff here.\n      grunt.log.muted = true;\n      // Initialize task system so that available tasks can be listed.\n      grunt.task.init([], {help: true});\n      // Re-enable logging.\n      grunt.log.muted = false;\n\n      // Display available tasks (for shell completion, etc).\n      _tasks = Object.keys(grunt.task._tasks).sort();\n      verbose.writeln('Available tasks: ' + _tasks.join(' '));\n\n      // Display available options (for shell completion, etc).\n      _options = [];\n      Object.keys(grunt.cli.optlist).forEach(function(long) {\n        var o = grunt.cli.optlist[long];\n        _options.push('--' + (o.negate ? 'no-' : '') + long);\n        if (o.short) { _options.push('-' + o.short); }\n      });\n      verbose.writeln('Available options: ' + _options.join(' '));\n    }\n\n    return;\n  }\n\n  // Init colors.\n  log.initColors();\n\n  // Display help and quit if the user did --help.\n  if (option('help')) {\n    help.display();\n    return;\n  }\n\n  // A little header stuff.\n  verbose.header('Initializing').writeflags(option.flags(), 'Command-line options');\n\n  // Determine and output which tasks will be run.\n  var tasksSpecified = tasks && tasks.length > 0;\n  tasks = task.parseArgs([tasksSpecified ? tasks : 'default']);\n\n  // Initialize tasks.\n  task.init(tasks, options);\n\n  verbose.writeln();\n  if (!tasksSpecified) {\n    verbose.writeln('No tasks specified, running default tasks.');\n  }\n  verbose.writeflags(tasks, 'Running tasks');\n\n  // Handle otherwise unhandleable (probably asynchronous) exceptions.\n  var uncaughtHandler = function(e) {\n    fail.fatal(e, fail.code.TASK_FAILURE);\n  };\n  process.on('uncaughtException', uncaughtHandler);\n\n  // Report, etc when all tasks have completed.\n  task.options({\n    error: function(e) {\n      fail.warn(e, fail.code.TASK_FAILURE);\n    },\n    done: function() {\n      // Stop handling uncaught exceptions so that we don't leave any\n      // unwanted process-level side effects behind. There is no need to do\n      // this in the error callback, because fail.warn() will either kill\n      // the process, or with --force keep on going all the way here.\n      process.removeListener('uncaughtException', uncaughtHandler);\n\n      // Output a final fail / success report.\n      fail.report();\n\n      if (done) {\n        // Execute \"done\" function when done (only if passed, of course).\n        done();\n      } else {\n        // Otherwise, explicitly exit.\n        util.exit(0);\n      }\n    }\n  });\n\n  // Execute all tasks, in order. Passing each task individually in a forEach\n  // allows the error callback to execute multiple times.\n  tasks.forEach(function(name) { task.run(name); });\n  // Run tasks async internally to reduce call-stack, per:\n  // https://github.com/gruntjs/grunt/pull/1026\n  task.start({asyncDone: true});\n};\n","/home/travis/build/npmtest/node-npmtest-grunt/grunt/lib/util/task.js":"(function(exports) {\n\n  'use strict';\n\n  var grunt = require('../grunt');\n\n  // Construct-o-rama.\n  function Task() {\n    // Information about the currently-running task.\n    this.current = {};\n    // Tasks.\n    this._tasks = {};\n    // Task queue.\n    this._queue = [];\n    // Queue placeholder (for dealing with nested tasks).\n    this._placeholder = {placeholder: true};\n    // Queue marker (for clearing the queue programmatically).\n    this._marker = {marker: true};\n    // Options.\n    this._options = {};\n    // Is the queue running?\n    this._running = false;\n    // Success status of completed tasks.\n    this._success = {};\n  }\n\n  // Expose the constructor function.\n  exports.Task = Task;\n\n  // Create a new Task instance.\n  exports.create = function() {\n    return new Task();\n  };\n\n  // If the task runner is running or an error handler is not defined, throw\n  // an exception. Otherwise, call the error handler directly.\n  Task.prototype._throwIfRunning = function(obj) {\n    if (this._running || !this._options.error) {\n      // Throw an exception that the task runner will catch.\n      throw obj;\n    } else {\n      // Not inside the task runner. Call the error handler and abort.\n      this._options.error.call({name: null}, obj);\n    }\n  };\n\n  // Register a new task.\n  Task.prototype.registerTask = function(name, info, fn) {\n    // If optional \"info\" string is omitted, shuffle arguments a bit.\n    if (fn == null) {\n      fn = info;\n      info = null;\n    }\n    // String or array of strings was passed instead of fn.\n    var tasks;\n    if (typeof fn !== 'function') {\n      // Array of task names.\n      tasks = this.parseArgs([fn]);\n      // This task function just runs the specified tasks.\n      fn = this.run.bind(this, fn);\n      fn.alias = true;\n      // Generate an info string if one wasn't explicitly passed.\n      if (!info) {\n        info = 'Alias for \"' + tasks.join('\", \"') + '\" task' +\n          (tasks.length === 1 ? '' : 's') + '.';\n      }\n    } else if (!info) {\n      info = 'Custom task.';\n    }\n    // Add task into cache.\n    this._tasks[name] = {name: name, info: info, fn: fn};\n    // Make chainable!\n    return this;\n  };\n\n  // Is the specified task an alias?\n  Task.prototype.isTaskAlias = function(name) {\n    return !!this._tasks[name].fn.alias;\n  };\n\n  // Has the specified task been registered?\n  Task.prototype.exists = function(name) {\n    return name in this._tasks;\n  };\n\n  // Rename a task. This might be useful if you want to override the default\n  // behavior of a task, while retaining the old name. This is a billion times\n  // easier to implement than some kind of in-task \"super\" functionality.\n  Task.prototype.renameTask = function(oldname, newname) {\n    if (!this._tasks[oldname]) {\n      throw new Error('Cannot rename missing \"' + oldname + '\" task.');\n    }\n    // Rename task.\n    this._tasks[newname] = this._tasks[oldname];\n    // Update name property of task.\n    this._tasks[newname].name = newname;\n    // Remove old name.\n    delete this._tasks[oldname];\n    // Make chainable!\n    return this;\n  };\n\n  // Argument parsing helper. Supports these signatures:\n  //  fn('foo')                 // ['foo']\n  //  fn('foo', 'bar', 'baz')   // ['foo', 'bar', 'baz']\n  //  fn(['foo', 'bar', 'baz']) // ['foo', 'bar', 'baz']\n  Task.prototype.parseArgs = function(args) {\n    // Return the first argument if it's an array, otherwise return an array\n    // of all arguments.\n    return Array.isArray(args[0]) ? args[0] : [].slice.call(args);\n  };\n\n  // Split a colon-delimited string into an array, unescaping (but not\n  // splitting on) any \\: escaped colons.\n  Task.prototype.splitArgs = function(str) {\n    if (!str) { return []; }\n    // Store placeholder for \\\\ followed by \\:\n    str = str.replace(/\\\\\\\\/g, '\\uFFFF').replace(/\\\\:/g, '\\uFFFE');\n    // Split on :\n    return str.split(':').map(function(s) {\n      // Restore place-held : followed by \\\\\n      return s.replace(/\\uFFFE/g, ':').replace(/\\uFFFF/g, '\\\\');\n    });\n  };\n\n  // Given a task name, determine which actual task will be called, and what\n  // arguments will be passed into the task callback. \"foo\" -> task \"foo\", no\n  // args. \"foo:bar:baz\" -> task \"foo:bar:baz\" with no args (if \"foo:bar:baz\"\n  // task exists), otherwise task \"foo:bar\" with arg \"baz\" (if \"foo:bar\" task\n  // exists), otherwise task \"foo\" with args \"bar\" and \"baz\".\n  Task.prototype._taskPlusArgs = function(name) {\n    // Get task name / argument parts.\n    var parts = this.splitArgs(name);\n    // Start from the end, not the beginning!\n    var i = parts.length;\n    var task;\n    do {\n      // Get a task.\n      task = this._tasks[parts.slice(0, i).join(':')];\n      // If the task doesn't exist, decrement `i`, and if `i` is greater than\n      // 0, repeat.\n    } while (!task && --i > 0);\n    // Just the args.\n    var args = parts.slice(i);\n    // Maybe you want to use them as flags instead of as positional args?\n    var flags = {};\n    args.forEach(function(arg) { flags[arg] = true; });\n    // The task to run and the args to run it with.\n    return {task: task, nameArgs: name, args: args, flags: flags};\n  };\n\n  // Append things to queue in the correct spot.\n  Task.prototype._push = function(things) {\n    // Get current placeholder index.\n    var index = this._queue.indexOf(this._placeholder);\n    if (index === -1) {\n      // No placeholder, add task+args objects to end of queue.\n      this._queue = this._queue.concat(things);\n    } else {\n      // Placeholder exists, add task+args objects just before placeholder.\n      [].splice.apply(this._queue, [index, 0].concat(things));\n    }\n  };\n\n  // Enqueue a task.\n  Task.prototype.run = function() {\n    // Parse arguments into an array, returning an array of task+args objects.\n    var things = this.parseArgs(arguments).map(this._taskPlusArgs, this);\n    // Throw an exception if any tasks weren't found.\n    var fails = things.filter(function(thing) { return !thing.task; });\n    if (fails.length > 0) {\n      this._throwIfRunning(new Error('Task \"' + fails[0].nameArgs + '\" not found.'));\n      return this;\n    }\n    // Append things to queue in the correct spot.\n    this._push(things);\n    // Make chainable!\n    return this;\n  };\n\n  // Add a marker to the queue to facilitate clearing it programmatically.\n  Task.prototype.mark = function() {\n    this._push(this._marker);\n    // Make chainable!\n    return this;\n  };\n\n  // Run a task function, handling this.async / return value.\n  Task.prototype.runTaskFn = function(context, fn, done, asyncDone) {\n    // Async flag.\n    var async = false;\n\n    // Update the internal status object and run the next task.\n    var complete = function(success) {\n      var err = null;\n      if (success === false) {\n        // Since false was passed, the task failed generically.\n        err = new Error('Task \"' + context.nameArgs + '\" failed.');\n      } else if (success instanceof Error || {}.toString.call(success) === '[object Error]') {\n        // An error object was passed, so the task failed specifically.\n        err = success;\n        success = false;\n      } else {\n        // The task succeeded.\n        success = true;\n      }\n      // The task has ended, reset the current task object.\n      this.current = {};\n      // A task has \"failed\" only if it returns false (async) or if the\n      // function returned by .async is passed false.\n      this._success[context.nameArgs] = success;\n      // If task failed, call error handler.\n      if (!success && this._options.error) {\n        this._options.error.call({name: context.name, nameArgs: context.nameArgs}, err);\n      }\n      // only call done async if explicitly requested to\n      // see: https://github.com/gruntjs/grunt/pull/1026\n      if (asyncDone) {\n        process.nextTick(function() {\n          done(err, success);\n        });\n      } else {\n        done(err, success);\n      }\n    }.bind(this);\n\n    // When called, sets the async flag and returns a function that can\n    // be used to continue processing the queue.\n    context.async = function() {\n      async = true;\n      // The returned function should execute asynchronously in case\n      // someone tries to do this.async()(); inside a task (WTF).\n      return grunt.util._.once(function(success) {\n        setTimeout(function() { complete(success); }, 1);\n      });\n    };\n\n    // Expose some information about the currently-running task.\n    this.current = context;\n\n    try {\n      // Get the current task and run it, setting `this` inside the task\n      // function to be something useful.\n      var success = fn.call(context);\n      // If the async flag wasn't set, process the next task in the queue.\n      if (!async) {\n        complete(success);\n      }\n    } catch (err) {\n      complete(err);\n    }\n  };\n\n  // Begin task queue processing. Ie. run all tasks.\n  Task.prototype.start = function(opts) {\n    if (!opts) {\n      opts = {};\n    }\n    // Abort if already running.\n    if (this._running) { return false; }\n    // Actually process the next task.\n    var nextTask = function() {\n      // Get next task+args object from queue.\n      var thing;\n      // Skip any placeholders or markers.\n      do {\n        thing = this._queue.shift();\n      } while (thing === this._placeholder || thing === this._marker);\n      // If queue was empty, we're all done.\n      if (!thing) {\n        this._running = false;\n        if (this._options.done) {\n          this._options.done();\n        }\n        return;\n      }\n      // Add a placeholder to the front of the queue.\n      this._queue.unshift(this._placeholder);\n\n      // Expose some information about the currently-running task.\n      var context = {\n        // The current task name plus args, as-passed.\n        nameArgs: thing.nameArgs,\n        // The current task name.\n        name: thing.task.name,\n        // The current task arguments.\n        args: thing.args,\n        // The current arguments, available as named flags.\n        flags: thing.flags\n      };\n\n      // Actually run the task function (handling this.async, etc)\n      this.runTaskFn(context, function() {\n        return thing.task.fn.apply(this, this.args);\n      }, nextTask, !!opts.asyncDone);\n\n    }.bind(this);\n\n    // Update flag.\n    this._running = true;\n    // Process the next task.\n    nextTask();\n  };\n\n  // Clear remaining tasks from the queue.\n  Task.prototype.clearQueue = function(options) {\n    if (!options) { options = {}; }\n    if (options.untilMarker) {\n      this._queue.splice(0, this._queue.indexOf(this._marker) + 1);\n    } else {\n      this._queue = [];\n    }\n    // Make chainable!\n    return this;\n  };\n\n  // Test to see if all of the given tasks have succeeded.\n  Task.prototype.requires = function() {\n    this.parseArgs(arguments).forEach(function(name) {\n      var success = this._success[name];\n      if (!success) {\n        throw new Error('Required task \"' + name +\n          '\" ' + (success === false ? 'failed' : 'must be run first') + '.');\n      }\n    }.bind(this));\n  };\n\n  // Override default options.\n  Task.prototype.options = function(options) {\n    Object.keys(options).forEach(function(name) {\n      this._options[name] = options[name];\n    }.bind(this));\n  };\n\n}(typeof exports === 'object' && exports || this));\n","/home/travis/build/npmtest/node-npmtest-grunt/grunt/lib/grunt/template.js":"'use strict';\n\nvar grunt = require('../grunt');\n\n// The module to be exported.\nvar template = module.exports = {};\n\n// External libs.\ntemplate.date = require('dateformat');\n\n// Format today's date.\ntemplate.today = function(format) {\n  return template.date(new Date(), format);\n};\n\n// Template delimiters.\nvar allDelimiters = {};\n\n// Initialize template delimiters.\ntemplate.addDelimiters = function(name, opener, closer) {\n  var delimiters = allDelimiters[name] = {};\n  // Used by grunt.\n  delimiters.opener = opener;\n  delimiters.closer = closer;\n  // Generate RegExp patterns dynamically.\n  var a = delimiters.opener.replace(/(.)/g, '\\\\$1');\n  var b = '([\\\\s\\\\S]+?)' + delimiters.closer.replace(/(.)/g, '\\\\$1');\n  // Used by Lo-Dash.\n  delimiters.lodash = {\n    evaluate: new RegExp(a + b, 'g'),\n    interpolate: new RegExp(a + '=' + b, 'g'),\n    escape: new RegExp(a + '-' + b, 'g')\n  };\n};\n\n// The underscore default template syntax should be a pretty sane default for\n// the config system.\ntemplate.addDelimiters('config', '<%', '%>');\n\n// Set Lo-Dash template delimiters.\ntemplate.setDelimiters = function(name) {\n  // Get the appropriate delimiters.\n  var delimiters = allDelimiters[name in allDelimiters ? name : 'config'];\n  // Tell Lo-Dash which delimiters to use.\n  grunt.util._.extend(grunt.util._.templateSettings, delimiters.lodash);\n  // Return the delimiters.\n  return delimiters;\n};\n\n// Process template + data with Lo-Dash.\ntemplate.process = function(tmpl, options) {\n  if (!options) { options = {}; }\n  // Set delimiters, and get a opening match character.\n  var delimiters = template.setDelimiters(options.delimiters);\n  // Clone data, initializing to config data or empty object if omitted.\n  var data = Object.create(options.data || grunt.config.data || {});\n  // Expose grunt so that grunt utilities can be accessed, but only if it\n  // doesn't conflict with an existing .grunt property.\n  if (!('grunt' in data)) { data.grunt = grunt; }\n  // Keep track of last change.\n  var last = tmpl;\n  try {\n    // As long as tmpl contains template tags, render it and get the result,\n    // otherwise just use the template string.\n    while (tmpl.indexOf(delimiters.opener) >= 0) {\n      tmpl = grunt.util._.template(tmpl, options)(data);\n      // Abort if template didn't change - nothing left to process!\n      if (tmpl === last) { break; }\n      last = tmpl;\n    }\n  } catch (e) {\n    // In upgrading to Lo-Dash (or Underscore.js 1.3.3), \\n and \\r in template\n    // tags now causes an exception to be thrown. Warn the user why this is\n    // happening. https://github.com/documentcloud/underscore/issues/553\n    if (String(e) === 'SyntaxError: Unexpected token ILLEGAL' && /\\n|\\r/.test(tmpl)) {\n      grunt.log.errorlns('A special character was detected in this template. ' +\n        'Inside template tags, the \\\\n and \\\\r special characters must be ' +\n        'escaped as \\\\\\\\n and \\\\\\\\r. (grunt 0.4.0+)');\n    }\n    // Slightly better error message.\n    e.message = 'An error occurred while processing a template (' + e.message + ').';\n    grunt.warn(e, grunt.fail.code.TEMPLATE_ERROR);\n  }\n  // Normalize linefeeds and return.\n  return grunt.util.normalizelf(tmpl);\n};\n","/home/travis/build/npmtest/node-npmtest-grunt/grunt/lib/grunt/event.js":"'use strict';\n\n// External lib.\nvar EventEmitter2 = require('eventemitter2').EventEmitter2;\n\n// Awesome.\nmodule.exports = new EventEmitter2({wildcard: true});\n","/home/travis/build/npmtest/node-npmtest-grunt/grunt/lib/grunt/fail.js":"'use strict';\n\nvar grunt = require('../grunt');\n\n// The module to be exported.\nvar fail = module.exports = {};\n\n// Error codes.\nfail.code = {\n  FATAL_ERROR: 1,\n  MISSING_GRUNTFILE: 2,\n  TASK_FAILURE: 3,\n  TEMPLATE_ERROR: 4,\n  INVALID_AUTOCOMPLETE: 5,\n  WARNING: 6,\n};\n\n// DRY it up!\nfunction writeln(e, mode) {\n  grunt.log.muted = false;\n  var msg = String(e.message || e);\n  if (!grunt.option('no-color')) { msg += '\\x07'; } // Beep!\n  if (mode === 'warn') {\n    msg = 'Warning: ' + msg + ' ';\n    msg += (grunt.option('force') ? 'Used --force, continuing.'.underline : 'Use --force to continue.');\n    msg = msg.yellow;\n  } else {\n    msg = ('Fatal error: ' + msg).red;\n  }\n  grunt.log.writeln(msg);\n}\n\n// If --stack is enabled, log the appropriate error stack (if it exists).\nfunction dumpStack(e) {\n  if (grunt.option('stack')) {\n    if (e.origError && e.origError.stack) {\n      console.log(e.origError.stack);\n    } else if (e.stack) {\n      console.log(e.stack);\n    }\n  }\n}\n\n// A fatal error occurred. Abort immediately.\nfail.fatal = function(e, errcode) {\n  writeln(e, 'fatal');\n  dumpStack(e);\n  grunt.util.exit(typeof errcode === 'number' ? errcode : fail.code.FATAL_ERROR);\n};\n\n// Keep track of error and warning counts.\nfail.errorcount = 0;\nfail.warncount = 0;\n\n// A warning occurred. Abort immediately unless -f or --force was used.\nfail.warn = function(e, errcode) {\n  var message = typeof e === 'string' ? e : e.message;\n  fail.warncount++;\n  writeln(message, 'warn');\n  // If -f or --force aren't used, stop script processing.\n  if (!grunt.option('force')) {\n    dumpStack(e);\n    grunt.log.writeln().fail('Aborted due to warnings.');\n    grunt.util.exit(typeof errcode === 'number' ? errcode : fail.code.WARNING);\n  }\n};\n\n// This gets called at the very end.\nfail.report = function() {\n  if (fail.warncount > 0) {\n    grunt.log.writeln().fail('Done, but with warnings.');\n  } else {\n    grunt.log.writeln().success('Done.');\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-grunt/grunt/lib/grunt/file.js":"'use strict';\n\nvar grunt = require('../grunt');\n\n// Nodejs libs.\nvar fs = require('fs');\nvar path = require('path');\n\n// The module to be exported.\nvar file = module.exports = {};\n\n// External libs.\nfile.glob = require('glob');\nfile.minimatch = require('minimatch');\nfile.findup = require('findup-sync');\nvar YAML = require('js-yaml');\nvar rimraf = require('rimraf');\nvar iconv = require('iconv-lite');\nvar pathIsAbsolute = require('path-is-absolute');\n\n// Windows?\nvar win32 = process.platform === 'win32';\n\n// Normalize \\\\ paths to / paths.\nvar unixifyPath = function(filepath) {\n  if (win32) {\n    return filepath.replace(/\\\\/g, '/');\n  } else {\n    return filepath;\n  }\n};\n\n// Change the current base path (ie, CWD) to the specified path.\nfile.setBase = function() {\n  var dirpath = path.join.apply(path, arguments);\n  process.chdir(dirpath);\n};\n\n// Process specified wildcard glob patterns or filenames against a\n// callback, excluding and uniquing files in the result set.\nvar processPatterns = function(patterns, fn) {\n  // Filepaths to return.\n  var result = [];\n  // Iterate over flattened patterns array.\n  grunt.util._.flattenDeep(patterns).forEach(function(pattern) {\n    // If the first character is ! it should be omitted\n    var exclusion = pattern.indexOf('!') === 0;\n    // If the pattern is an exclusion, remove the !\n    if (exclusion) { pattern = pattern.slice(1); }\n    // Find all matching files for this pattern.\n    var matches = fn(pattern);\n    if (exclusion) {\n      // If an exclusion, remove matching files.\n      result = grunt.util._.difference(result, matches);\n    } else {\n      // Otherwise add matching files.\n      result = grunt.util._.union(result, matches);\n    }\n  });\n  return result;\n};\n\n// Match a filepath or filepaths against one or more wildcard patterns. Returns\n// all matching filepaths.\nfile.match = function(options, patterns, filepaths) {\n  if (grunt.util.kindOf(options) !== 'object') {\n    filepaths = patterns;\n    patterns = options;\n    options = {};\n  }\n  // Return empty set if either patterns or filepaths was omitted.\n  if (patterns == null || filepaths == null) { return []; }\n  // Normalize patterns and filepaths to arrays.\n  if (!Array.isArray(patterns)) { patterns = [patterns]; }\n  if (!Array.isArray(filepaths)) { filepaths = [filepaths]; }\n  // Return empty set if there are no patterns or filepaths.\n  if (patterns.length === 0 || filepaths.length === 0) { return []; }\n  // Return all matching filepaths.\n  return processPatterns(patterns, function(pattern) {\n    return file.minimatch.match(filepaths, pattern, options);\n  });\n};\n\n// Match a filepath or filepaths against one or more wildcard patterns. Returns\n// true if any of the patterns match.\nfile.isMatch = function() {\n  return file.match.apply(file, arguments).length > 0;\n};\n\n// Return an array of all file paths that match the given wildcard patterns.\nfile.expand = function() {\n  var args = grunt.util.toArray(arguments);\n  // If the first argument is an options object, save those options to pass\n  // into the file.glob.sync method.\n  var options = grunt.util.kindOf(args[0]) === 'object' ? args.shift() : {};\n  // Use the first argument if it's an Array, otherwise convert the arguments\n  // object to an array and use that.\n  var patterns = Array.isArray(args[0]) ? args[0] : args;\n  // Return empty set if there are no patterns or filepaths.\n  if (patterns.length === 0) { return []; }\n  // Return all matching filepaths.\n  var matches = processPatterns(patterns, function(pattern) {\n    // Find all matching files for this pattern.\n    return file.glob.sync(pattern, options);\n  });\n  // Filter result set?\n  if (options.filter) {\n    matches = matches.filter(function(filepath) {\n      filepath = path.join(options.cwd || '', filepath);\n      try {\n        if (typeof options.filter === 'function') {\n          return options.filter(filepath);\n        } else {\n          // If the file is of the right type and exists, this should work.\n          return fs.statSync(filepath)[options.filter]();\n        }\n      } catch (e) {\n        // Otherwise, it's probably not the right type.\n        return false;\n      }\n    });\n  }\n  return matches;\n};\n\nvar pathSeparatorRe = /[\\/\\\\]/g;\n\n// The \"ext\" option refers to either everything after the first dot (default)\n// or everything after the last dot.\nvar extDotRe = {\n  first: /(\\.[^\\/]*)?$/,\n  last: /(\\.[^\\/\\.]*)?$/,\n};\n\n// Build a multi task \"files\" object dynamically.\nfile.expandMapping = function(patterns, destBase, options) {\n  options = grunt.util._.defaults({}, options, {\n    extDot: 'first',\n    rename: function(destBase, destPath) {\n      return path.join(destBase || '', destPath);\n    }\n  });\n  var files = [];\n  var fileByDest = {};\n  // Find all files matching pattern, using passed-in options.\n  file.expand(options, patterns).forEach(function(src) {\n    var destPath = src;\n    // Flatten?\n    if (options.flatten) {\n      destPath = path.basename(destPath);\n    }\n    // Change the extension?\n    if ('ext' in options) {\n      destPath = destPath.replace(extDotRe[options.extDot], options.ext);\n    }\n    // Generate destination filename.\n    var dest = options.rename(destBase, destPath, options);\n    // Prepend cwd to src path if necessary.\n    if (options.cwd) { src = path.join(options.cwd, src); }\n    // Normalize filepaths to be unix-style.\n    dest = dest.replace(pathSeparatorRe, '/');\n    src = src.replace(pathSeparatorRe, '/');\n    // Map correct src path to dest path.\n    if (fileByDest[dest]) {\n      // If dest already exists, push this src onto that dest's src array.\n      fileByDest[dest].src.push(src);\n    } else {\n      // Otherwise create a new src-dest file mapping object.\n      files.push({\n        src: [src],\n        dest: dest,\n      });\n      // And store a reference for later use.\n      fileByDest[dest] = files[files.length - 1];\n    }\n  });\n  return files;\n};\n\n// Like mkdir -p. Create a directory and any intermediary directories.\nfile.mkdir = function(dirpath, mode) {\n  if (grunt.option('no-write')) { return; }\n  // Set directory mode in a strict-mode-friendly way.\n  if (mode == null) {\n    mode = parseInt('0777', 8) & (~process.umask());\n  }\n  dirpath.split(pathSeparatorRe).reduce(function(parts, part) {\n    parts += part + '/';\n    var subpath = path.resolve(parts);\n    if (!file.exists(subpath)) {\n      try {\n        fs.mkdirSync(subpath, mode);\n      } catch (e) {\n        throw grunt.util.error('Unable to create directory \"' + subpath + '\" (Error code: ' + e.code + ').', e);\n      }\n    }\n    return parts;\n  }, '');\n};\n\n// Recurse into a directory, executing callback for each file.\nfile.recurse = function recurse(rootdir, callback, subdir) {\n  var abspath = subdir ? path.join(rootdir, subdir) : rootdir;\n  fs.readdirSync(abspath).forEach(function(filename) {\n    var filepath = path.join(abspath, filename);\n    if (fs.statSync(filepath).isDirectory()) {\n      recurse(rootdir, callback, unixifyPath(path.join(subdir || '', filename || '')));\n    } else {\n      callback(unixifyPath(filepath), rootdir, subdir, filename);\n    }\n  });\n};\n\n// The default file encoding to use.\nfile.defaultEncoding = 'utf8';\n// Whether to preserve the BOM on file.read rather than strip it.\nfile.preserveBOM = false;\n\n// Read a file, return its contents.\nfile.read = function(filepath, options) {\n  if (!options) { options = {}; }\n  var contents;\n  grunt.verbose.write('Reading ' + filepath + '...');\n  try {\n    contents = fs.readFileSync(String(filepath));\n    // If encoding is not explicitly null, convert from encoded buffer to a\n    // string. If no encoding was specified, use the default.\n    if (options.encoding !== null) {\n      contents = iconv.decode(contents, options.encoding || file.defaultEncoding, {stripBOM: !file.preserveBOM});\n    }\n    grunt.verbose.ok();\n    return contents;\n  } catch (e) {\n    grunt.verbose.error();\n    throw grunt.util.error('Unable to read \"' + filepath + '\" file (Error code: ' + e.code + ').', e);\n  }\n};\n\n// Read a file, parse its contents, return an object.\nfile.readJSON = function(filepath, options) {\n  var src = file.read(filepath, options);\n  var result;\n  grunt.verbose.write('Parsing ' + filepath + '...');\n  try {\n    result = JSON.parse(src);\n    grunt.verbose.ok();\n    return result;\n  } catch (e) {\n    grunt.verbose.error();\n    throw grunt.util.error('Unable to parse \"' + filepath + '\" file (' + e.message + ').', e);\n  }\n};\n\n// Read a YAML file, parse its contents, return an object.\nfile.readYAML = function(filepath, options) {\n  var src = file.read(filepath, options);\n  var result;\n  grunt.verbose.write('Parsing ' + filepath + '...');\n  try {\n    result = YAML.load(src);\n    grunt.verbose.ok();\n    return result;\n  } catch (e) {\n    grunt.verbose.error();\n    throw grunt.util.error('Unable to parse \"' + filepath + '\" file (' + e.problem + ').', e);\n  }\n};\n\n// Write a file.\nfile.write = function(filepath, contents, options) {\n  if (!options) { options = {}; }\n  var nowrite = grunt.option('no-write');\n  grunt.verbose.write((nowrite ? 'Not actually writing ' : 'Writing ') + filepath + '...');\n  // Create path, if necessary.\n  file.mkdir(path.dirname(filepath));\n  try {\n    // If contents is already a Buffer, don't try to encode it. If no encoding\n    // was specified, use the default.\n    if (!Buffer.isBuffer(contents)) {\n      contents = iconv.encode(contents, options.encoding || file.defaultEncoding);\n    }\n    // Actually write file.\n    if (!nowrite) {\n      fs.writeFileSync(filepath, contents, 'mode' in options ? {mode: options.mode} : {});\n    }\n    grunt.verbose.ok();\n    return true;\n  } catch (e) {\n    grunt.verbose.error();\n    throw grunt.util.error('Unable to write \"' + filepath + '\" file (Error code: ' + e.code + ').', e);\n  }\n};\n\n// Read a file, optionally processing its content, then write the output.\n// Or read a directory, recursively creating directories, reading files,\n// processing content, writing output.\nfile.copy = function copy(srcpath, destpath, options) {\n  if (file.isDir(srcpath)) {\n    // Copy a directory, recursively.\n    // Explicitly create new dest directory.\n    file.mkdir(destpath);\n    // Iterate over all sub-files/dirs, recursing.\n    fs.readdirSync(srcpath).forEach(function(filepath) {\n      copy(path.join(srcpath, filepath), path.join(destpath, filepath), options);\n    });\n  } else {\n    // Copy a single file.\n    file._copy(srcpath, destpath, options);\n  }\n};\n\n// Read a file, optionally processing its content, then write the output.\nfile._copy = function(srcpath, destpath, options) {\n  if (!options) { options = {}; }\n  // If a process function was specified, and noProcess isn't true or doesn't\n  // match the srcpath, process the file's source.\n  var process = options.process && options.noProcess !== true &&\n    !(options.noProcess && file.isMatch(options.noProcess, srcpath));\n  // If the file will be processed, use the encoding as-specified. Otherwise,\n  // use an encoding of null to force the file to be read/written as a Buffer.\n  var readWriteOptions = process ? options : {encoding: null};\n  // Actually read the file.\n  var contents = file.read(srcpath, readWriteOptions);\n  if (process) {\n    grunt.verbose.write('Processing source...');\n    try {\n      contents = options.process(contents, srcpath, destpath);\n      grunt.verbose.ok();\n    } catch (e) {\n      grunt.verbose.error();\n      throw grunt.util.error('Error while processing \"' + srcpath + '\" file.', e);\n    }\n  }\n  // Abort copy if the process function returns false.\n  if (contents === false) {\n    grunt.verbose.writeln('Write aborted.');\n  } else {\n    file.write(destpath, contents, readWriteOptions);\n  }\n};\n\n// Delete folders and files recursively\nfile.delete = function(filepath, options) {\n  filepath = String(filepath);\n\n  var nowrite = grunt.option('no-write');\n  if (!options) {\n    options = {force: grunt.option('force') || false};\n  }\n\n  grunt.verbose.write((nowrite ? 'Not actually deleting ' : 'Deleting ') + filepath + '...');\n\n  if (!file.exists(filepath)) {\n    grunt.verbose.error();\n    grunt.log.warn('Cannot delete nonexistent file.');\n    return false;\n  }\n\n  // Only delete cwd or outside cwd if --force enabled. Be careful, people!\n  if (!options.force) {\n    if (file.isPathCwd(filepath)) {\n      grunt.verbose.error();\n      grunt.fail.warn('Cannot delete the current working directory.');\n      return false;\n    } else if (!file.isPathInCwd(filepath)) {\n      grunt.verbose.error();\n      grunt.fail.warn('Cannot delete files outside the current working directory.');\n      return false;\n    }\n  }\n\n  try {\n    // Actually delete. Or not.\n    if (!nowrite) {\n      rimraf.sync(filepath);\n    }\n    grunt.verbose.ok();\n    return true;\n  } catch (e) {\n    grunt.verbose.error();\n    throw grunt.util.error('Unable to delete \"' + filepath + '\" file (' + e.message + ').', e);\n  }\n};\n\n// True if the file path exists.\nfile.exists = function() {\n  var filepath = path.join.apply(path, arguments);\n  return fs.existsSync(filepath);\n};\n\n// True if the file is a symbolic link.\nfile.isLink = function() {\n  var filepath = path.join.apply(path, arguments);\n  return file.exists(filepath) && fs.lstatSync(filepath).isSymbolicLink();\n};\n\n// True if the path is a directory.\nfile.isDir = function() {\n  var filepath = path.join.apply(path, arguments);\n  return file.exists(filepath) && fs.statSync(filepath).isDirectory();\n};\n\n// True if the path is a file.\nfile.isFile = function() {\n  var filepath = path.join.apply(path, arguments);\n  return file.exists(filepath) && fs.statSync(filepath).isFile();\n};\n\n// Is a given file path absolute?\nfile.isPathAbsolute = function() {\n  var filepath = path.join.apply(path, arguments);\n  return pathIsAbsolute(filepath);\n};\n\n// Do all the specified paths refer to the same path?\nfile.arePathsEquivalent = function(first) {\n  first = path.resolve(first);\n  for (var i = 1; i < arguments.length; i++) {\n    if (first !== path.resolve(arguments[i])) { return false; }\n  }\n  return true;\n};\n\n// Are descendant path(s) contained within ancestor path? Note: does not test\n// if paths actually exist.\nfile.doesPathContain = function(ancestor) {\n  ancestor = path.resolve(ancestor);\n  var relative;\n  for (var i = 1; i < arguments.length; i++) {\n    relative = path.relative(path.resolve(arguments[i]), ancestor);\n    if (relative === '' || /\\w+/.test(relative)) { return false; }\n  }\n  return true;\n};\n\n// Test to see if a filepath is the CWD.\nfile.isPathCwd = function() {\n  var filepath = path.join.apply(path, arguments);\n  try {\n    return file.arePathsEquivalent(fs.realpathSync(process.cwd()), fs.realpathSync(filepath));\n  } catch (e) {\n    return false;\n  }\n};\n\n// Test to see if a filepath is contained within the CWD.\nfile.isPathInCwd = function() {\n  var filepath = path.join.apply(path, arguments);\n  try {\n    return file.doesPathContain(fs.realpathSync(process.cwd()), fs.realpathSync(filepath));\n  } catch (e) {\n    return false;\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-grunt/grunt/lib/grunt/option.js":"'use strict';\n\n// The actual option data.\nvar data = {};\n\n// Get or set an option value.\nvar option = module.exports = function(key, value) {\n  var no = key.match(/^no-(.+)$/);\n  if (arguments.length === 2) {\n    return (data[key] = value);\n  } else if (no) {\n    return data[no[1]] === false;\n  } else {\n    return data[key];\n  }\n};\n\n// Initialize option data.\noption.init = function(obj) {\n  return (data = obj || {});\n};\n\n// List of options as flags.\noption.flags = function() {\n  return Object.keys(data).filter(function(key) {\n    // Don't display empty arrays.\n    return !(Array.isArray(data[key]) && data[key].length === 0);\n  }).map(function(key) {\n    var val = data[key];\n    return '--' + (val === false ? 'no-' : '') + key +\n      (typeof val === 'boolean' ? '' : '=' + val);\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-grunt/grunt/lib/grunt/config.js":"'use strict';\n\nvar grunt = require('../grunt');\n\n// Get/set config data. If value was passed, set. Otherwise, get.\nvar config = module.exports = function(prop, value) {\n  if (arguments.length === 2) {\n    // Two arguments were passed, set the property's value.\n    return config.set(prop, value);\n  } else {\n    // Get the property's value (or the entire data object).\n    return config.get(prop);\n  }\n};\n\n// The actual config data.\nconfig.data = {};\n\n// Escape any . in name with \\. so dot-based namespacing works properly.\nconfig.escape = function(str) {\n  return str.replace(/\\./g, '\\\\.');\n};\n\n// Return prop as a string.\nconfig.getPropString = function(prop) {\n  return Array.isArray(prop) ? prop.map(config.escape).join('.') : prop;\n};\n\n// Get raw, unprocessed config data.\nconfig.getRaw = function(prop) {\n  if (prop) {\n    // Prop was passed, get that specific property's value.\n    return grunt.util.namespace.get(config.data, config.getPropString(prop));\n  } else {\n    // No prop was passed, return the entire config.data object.\n    return config.data;\n  }\n};\n\n// Match '<%= FOO %>' where FOO is a propString, eg. foo or foo.bar but not\n// a method call like foo() or foo.bar().\nvar propStringTmplRe = /^<%=\\s*([a-z0-9_$]+(?:\\.[a-z0-9_$]+)*)\\s*%>$/i;\n\n// Get config data, recursively processing templates.\nconfig.get = function(prop) {\n  return config.process(config.getRaw(prop));\n};\n\n// Expand a config value recursively. Used for post-processing raw values\n// already retrieved from the config.\nconfig.process = function(raw) {\n  return grunt.util.recurse(raw, function(value) {\n    // If the value is not a string, return it.\n    if (typeof value !== 'string') { return value; }\n    // If possible, access the specified property via config.get, in case it\n    // doesn't refer to a string, but instead refers to an object or array.\n    var matches = value.match(propStringTmplRe);\n    var result;\n    if (matches) {\n      result = config.get(matches[1]);\n      // If the result retrieved from the config data wasn't null or undefined,\n      // return it.\n      if (result != null) { return result; }\n    }\n    // Process the string as a template.\n    return grunt.template.process(value, {data: config.data});\n  });\n};\n\n// Set config data.\nconfig.set = function(prop, value) {\n  return grunt.util.namespace.set(config.data, config.getPropString(prop), value);\n};\n\n// Deep merge config data.\nconfig.merge = function(obj) {\n  grunt.util._.merge(config.data, obj);\n  return config.data;\n};\n\n// Initialize config data.\nconfig.init = function(obj) {\n  grunt.verbose.write('Initializing config...').ok();\n  // Initialize and return data.\n  return (config.data = obj || {});\n};\n\n// Test to see if required config params have been defined. If not, throw an\n// exception (use this inside of a task).\nconfig.requires = function() {\n  var p = grunt.util.pluralize;\n  var props = grunt.util.toArray(arguments).map(config.getPropString);\n  var msg = 'Verifying propert' + p(props.length, 'y/ies') +\n    ' ' + grunt.log.wordlist(props) + ' exist' + p(props.length, 's') +\n    ' in config...';\n  grunt.verbose.write(msg);\n  var failProps = config.data && props.filter(function(prop) {\n    return config.get(prop) == null;\n  }).map(function(prop) {\n    return '\"' + prop + '\"';\n  });\n  if (config.data && failProps.length === 0) {\n    grunt.verbose.ok();\n    return true;\n  } else {\n    grunt.verbose.or.write(msg);\n    grunt.log.error().error('Unable to process task.');\n    if (!config.data) {\n      throw grunt.util.error('Unable to load config.');\n    } else {\n      throw grunt.util.error('Required config propert' +\n        p(failProps.length, 'y/ies') + ' ' + failProps.join(', ') + ' missing.');\n    }\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-grunt/grunt/lib/grunt/task.js":"'use strict';\n\nvar grunt = require('../grunt');\n\n// Nodejs libs.\nvar path = require('path');\n\n// Extend generic \"task\" util lib.\nvar parent = grunt.util.task.create();\n\n// The module to be exported.\nvar task = module.exports = Object.create(parent);\n\n// A temporary registry of tasks and metadata.\nvar registry = {tasks: [], untasks: [], meta: {}};\n\n// The last specified tasks message.\nvar lastInfo;\n\n// Number of levels of recursion when loading tasks in collections.\nvar loadTaskDepth = 0;\n\n// Keep track of the number of log.error() calls.\nvar errorcount;\n\n// Override built-in registerTask.\ntask.registerTask = function(name) {\n  // Add task to registry.\n  registry.tasks.push(name);\n  // Register task.\n  parent.registerTask.apply(task, arguments);\n  // This task, now that it's been registered.\n  var thisTask = task._tasks[name];\n  // Metadata about the current task.\n  thisTask.meta = grunt.util._.clone(registry.meta);\n  // Override task function.\n  var _fn = thisTask.fn;\n  thisTask.fn = function(arg) {\n    // Guaranteed to always be the actual task name.\n    var name = thisTask.name;\n    // Initialize the errorcount for this task.\n    errorcount = grunt.fail.errorcount;\n    // Return the number of errors logged during this task.\n    Object.defineProperty(this, 'errorCount', {\n      enumerable: true,\n      get: function() {\n        return grunt.fail.errorcount - errorcount;\n      }\n    });\n    // Expose task.requires on `this`.\n    this.requires = task.requires.bind(task);\n    // Expose config.requires on `this`.\n    this.requiresConfig = grunt.config.requires;\n    // Return an options object with the specified defaults overwritten by task-\n    // specific overrides, via the \"options\" property.\n    this.options = function() {\n      var args = [{}].concat(grunt.util.toArray(arguments)).concat([\n        grunt.config([name, 'options'])\n      ]);\n      var options = grunt.util._.extend.apply(null, args);\n      grunt.verbose.writeflags(options, 'Options');\n      return options;\n    };\n    // If this task was an alias or a multi task called without a target,\n    // only log if in verbose mode.\n    var logger = _fn.alias || (thisTask.multi && (!arg || arg === '*')) ? 'verbose' : 'log';\n    // Actually log.\n    grunt[logger].header('Running \"' + this.nameArgs + '\"' +\n      (this.name !== this.nameArgs ? ' (' + this.name + ')' : '') + ' task');\n    // If --debug was specified, log the path to this task's source file.\n    grunt[logger].debug('Task source: ' + thisTask.meta.filepath);\n    // Actually run the task.\n    return _fn.apply(this, arguments);\n  };\n  return task;\n};\n\n// Multi task targets can't start with _ or be a reserved property (options).\nfunction isValidMultiTaskTarget(target) {\n  return !/^_|^options$/.test(target);\n}\n\n// Normalize multi task files.\ntask.normalizeMultiTaskFiles = function(data, target) {\n  var prop, obj;\n  var files = [];\n  if (grunt.util.kindOf(data) === 'object') {\n    if ('src' in data || 'dest' in data) {\n      obj = {};\n      for (prop in data) {\n        if (prop !== 'options') {\n          obj[prop] = data[prop];\n        }\n      }\n      files.push(obj);\n    } else if (grunt.util.kindOf(data.files) === 'object') {\n      for (prop in data.files) {\n        files.push({src: data.files[prop], dest: grunt.config.process(prop)});\n      }\n    } else if (Array.isArray(data.files)) {\n      grunt.util._.flattenDeep(data.files).forEach(function(obj) {\n        var prop;\n        if ('src' in obj || 'dest' in obj) {\n          files.push(obj);\n        } else {\n          for (prop in obj) {\n            files.push({src: obj[prop], dest: grunt.config.process(prop)});\n          }\n        }\n      });\n    }\n  } else {\n    files.push({src: data, dest: grunt.config.process(target)});\n  }\n\n  // If no src/dest or files were specified, return an empty files array.\n  if (files.length === 0) {\n    grunt.verbose.writeln('File: ' + '[no files]'.yellow);\n    return [];\n  }\n\n  // Process all normalized file objects.\n  files = grunt.util._(files).chain().forEach(function(obj) {\n    if (!('src' in obj) || !obj.src) { return; }\n    // Normalize .src properties to flattened array.\n    if (Array.isArray(obj.src)) {\n      obj.src = grunt.util._.flatten(obj.src);\n    } else {\n      obj.src = [obj.src];\n    }\n  }).map(function(obj) {\n    // Build options object, removing unwanted properties.\n    var expandOptions = grunt.util._.extend({}, obj);\n    delete expandOptions.src;\n    delete expandOptions.dest;\n\n    // Expand file mappings.\n    if (obj.expand) {\n      return grunt.file.expandMapping(obj.src, obj.dest, expandOptions).map(function(mapObj) {\n        // Copy obj properties to result.\n        var result = grunt.util._.extend({}, obj);\n        // Make a clone of the orig obj available.\n        result.orig = grunt.util._.extend({}, obj);\n        // Set .src and .dest, processing both as templates.\n        result.src = grunt.config.process(mapObj.src);\n        result.dest = grunt.config.process(mapObj.dest);\n        // Remove unwanted properties.\n        ['expand', 'cwd', 'flatten', 'rename', 'ext'].forEach(function(prop) {\n          delete result[prop];\n        });\n        return result;\n      });\n    }\n\n    // Copy obj properties to result, adding an .orig property.\n    var result = grunt.util._.extend({}, obj);\n    // Make a clone of the orig obj available.\n    result.orig = grunt.util._.extend({}, obj);\n\n    if ('src' in result) {\n      // Expose an expand-on-demand getter method as .src.\n      Object.defineProperty(result, 'src', {\n        enumerable: true,\n        get: function fn() {\n          var src;\n          if (!('result' in fn)) {\n            src = obj.src;\n            // If src is an array, flatten it. Otherwise, make it into an array.\n            src = Array.isArray(src) ? grunt.util._.flatten(src) : [src];\n            // Expand src files, memoizing result.\n            fn.result = grunt.file.expand(expandOptions, src);\n          }\n          return fn.result;\n        }\n      });\n    }\n\n    if ('dest' in result) {\n      result.dest = obj.dest;\n    }\n\n    return result;\n  }).flatten().value();\n\n  // Log this.file src and dest properties when --verbose is specified.\n  if (grunt.option('verbose')) {\n    files.forEach(function(obj) {\n      var output = [];\n      if ('src' in obj) {\n        output.push(obj.src.length > 0 ? grunt.log.wordlist(obj.src) : '[no src]'.yellow);\n      }\n      if ('dest' in obj) {\n        output.push('-> ' + (obj.dest ? String(obj.dest).cyan : '[no dest]'.yellow));\n      }\n      if (output.length > 0) {\n        grunt.verbose.writeln('Files: ' + output.join(' '));\n      }\n    });\n  }\n\n  return files;\n};\n\n// This is the most common \"multi task\" pattern.\ntask.registerMultiTask = function(name, info, fn) {\n  // If optional \"info\" string is omitted, shuffle arguments a bit.\n  if (fn == null) {\n    fn = info;\n    info = 'Custom multi task.';\n  }\n  // Store a reference to the task object, in case the task gets renamed.\n  var thisTask;\n  task.registerTask(name, info, function(target) {\n    // Guaranteed to always be the actual task name.\n    var name = thisTask.name;\n    // Arguments (sans target) as an array.\n    this.args = grunt.util.toArray(arguments).slice(1);\n    // If a target wasn't specified, run this task once for each target.\n    if (!target || target === '*') {\n      return task.runAllTargets(name, this.args);\n    } else if (!isValidMultiTaskTarget(target)) {\n      throw new Error('Invalid target \"' + target + '\" specified.');\n    }\n    // Fail if any required config properties have been omitted.\n    this.requiresConfig([name, target]);\n    // Return an options object with the specified defaults overwritten by task-\n    // and/or target-specific overrides, via the \"options\" property.\n    this.options = function() {\n      var targetObj = grunt.config([name, target]);\n      var args = [{}].concat(grunt.util.toArray(arguments)).concat([\n        grunt.config([name, 'options']),\n        grunt.util.kindOf(targetObj) === 'object' ? targetObj.options : {}\n      ]);\n      var options = grunt.util._.extend.apply(null, args);\n      grunt.verbose.writeflags(options, 'Options');\n      return options;\n    };\n    // Expose the current target.\n    this.target = target;\n    // Recreate flags object so that the target isn't set as a flag.\n    this.flags = {};\n    this.args.forEach(function(arg) { this.flags[arg] = true; }, this);\n    // Expose data on `this` (as well as task.current).\n    this.data = grunt.config([name, target]);\n    // Expose normalized files object.\n    this.files = task.normalizeMultiTaskFiles(this.data, target);\n    // Expose normalized, flattened, uniqued array of src files.\n    Object.defineProperty(this, 'filesSrc', {\n      enumerable: true,\n      get: function() {\n        return grunt.util._(this.files).chain().map('src').flatten().uniq().value();\n      }.bind(this)\n    });\n    // Call original task function, passing in the target and any other args.\n    return fn.apply(this, this.args);\n  });\n\n  thisTask = task._tasks[name];\n  thisTask.multi = true;\n};\n\n// Init tasks don't require properties in config, and as such will preempt\n// config loading errors.\ntask.registerInitTask = function(name, info, fn) {\n  task.registerTask(name, info, fn);\n  task._tasks[name].init = true;\n};\n\n// Override built-in renameTask to use the registry.\ntask.renameTask = function(oldname, newname) {\n  var result;\n  try {\n    // Actually rename task.\n    result = parent.renameTask.apply(task, arguments);\n    // Add and remove task.\n    registry.untasks.push(oldname);\n    registry.tasks.push(newname);\n    // Return result.\n    return result;\n  } catch (e) {\n    grunt.log.error(e.message);\n  }\n};\n\n// If a property wasn't passed, run all task targets in turn.\ntask.runAllTargets = function(taskname, args) {\n  // Get an array of sub-property keys under the given config object.\n  var targets = Object.keys(grunt.config.getRaw(taskname) || {});\n  // Remove invalid target properties.\n  targets = targets.filter(isValidMultiTaskTarget);\n  // Fail if there are no actual properties to iterate over.\n  if (targets.length === 0) {\n    grunt.log.error('No \"' + taskname + '\" targets found.');\n    return false;\n  }\n  // Iterate over all targets, running a task for each.\n  targets.forEach(function(target) {\n    // Be sure to pass in any additionally specified args.\n    task.run([taskname, target].concat(args || []).join(':'));\n  });\n};\n\n// Load tasks and handlers from a given tasks file.\nvar loadTaskStack = [];\nfunction loadTask(filepath) {\n  // In case this was called recursively, save registry for later.\n  loadTaskStack.push(registry);\n  // Reset registry.\n  registry = {tasks: [], untasks: [], meta: {info: lastInfo, filepath: filepath}};\n  var filename = path.basename(filepath);\n  var msg = 'Loading \"' + filename + '\" tasks...';\n  var regCount = 0;\n  var fn;\n  try {\n    // Load taskfile.\n    fn = require(path.resolve(filepath));\n    if (typeof fn === 'function') {\n      fn.call(grunt, grunt);\n    }\n    grunt.verbose.write(msg).ok();\n    // Log registered/renamed/unregistered tasks.\n    ['un', ''].forEach(function(prefix) {\n      var list = grunt.util._.chain(registry[prefix + 'tasks']).uniq().sort().value();\n      if (list.length > 0) {\n        regCount++;\n        grunt.verbose.writeln((prefix ? '- ' : '+ ') + grunt.log.wordlist(list));\n      }\n    });\n    if (regCount === 0) {\n      grunt.verbose.warn('No tasks were registered or unregistered.');\n    }\n  } catch (e) {\n    // Something went wrong.\n    grunt.log.write(msg).error().verbose.error(e.stack).or.error(e);\n  }\n  // Restore registry.\n  registry = loadTaskStack.pop() || {};\n}\n\n// Log a message when loading tasks.\nfunction loadTasksMessage(info) {\n  // Only keep track of names of top-level loaded tasks and collections,\n  // not sub-tasks.\n  if (loadTaskDepth === 0) { lastInfo = info; }\n  grunt.verbose.subhead('Registering ' + info + ' tasks.');\n}\n\n// Load tasks and handlers from a given directory.\nfunction loadTasks(tasksdir) {\n  try {\n    var files = grunt.file.glob.sync('*.{js,coffee}', {cwd: tasksdir, maxDepth: 1});\n    // Load tasks from files.\n    files.forEach(function(filename) {\n      loadTask(path.join(tasksdir, filename));\n    });\n  } catch (e) {\n    grunt.log.verbose.error(e.stack).or.error(e);\n  }\n}\n\n// Load tasks and handlers from a given directory.\ntask.loadTasks = function(tasksdir) {\n  loadTasksMessage('\"' + tasksdir + '\"');\n  if (grunt.file.exists(tasksdir)) {\n    loadTasks(tasksdir);\n  } else {\n    grunt.log.error('Tasks directory \"' + tasksdir + '\" not found.');\n  }\n};\n\n// Load tasks and handlers from a given locally-installed Npm module (installed\n// relative to the base dir).\ntask.loadNpmTasks = function(name) {\n  loadTasksMessage('\"' + name + '\" local Npm module');\n  var root = path.resolve('node_modules');\n  var pkgfile = path.join(root, name, 'package.json');\n  var pkg = grunt.file.exists(pkgfile) ? grunt.file.readJSON(pkgfile) : {keywords: []};\n\n  // Process collection plugins.\n  if (pkg.keywords && pkg.keywords.indexOf('gruntcollection') !== -1) {\n    loadTaskDepth++;\n    Object.keys(pkg.dependencies).forEach(function(depName) {\n      // Npm sometimes pulls dependencies out if they're shared, so find\n      // upwards if not found locally.\n      var filepath = grunt.file.findup('node_modules/' + depName, {\n        cwd: path.resolve('node_modules', name),\n        nocase: true\n      });\n      if (filepath) {\n        // Load this task plugin recursively.\n        task.loadNpmTasks(path.relative(root, filepath));\n      }\n    });\n    loadTaskDepth--;\n    return;\n  }\n\n  // Process task plugins.\n  var tasksdir = path.join(root, name, 'tasks');\n  if (grunt.file.exists(tasksdir)) {\n    loadTasks(tasksdir);\n  } else {\n    grunt.log.error('Local Npm module \"' + name + '\" not found. Is it installed?');\n  }\n};\n\n// Initialize tasks.\ntask.init = function(tasks, options) {\n  if (!options) { options = {}; }\n\n  // Were only init tasks specified?\n  var allInit = tasks.length > 0 && tasks.every(function(name) {\n    var obj = task._taskPlusArgs(name).task;\n    return obj && obj.init;\n  });\n\n  // Get any local Gruntfile or tasks that might exist. Use --gruntfile override\n  // if specified, otherwise search the current directory or any parent.\n  var gruntfile, msg;\n  if (allInit || options.gruntfile === false) {\n    gruntfile = null;\n  } else {\n    gruntfile = grunt.option('gruntfile') ||\n      grunt.file.findup('Gruntfile.{js,coffee}', {nocase: true});\n    msg = 'Reading \"' + (gruntfile ? path.basename(gruntfile) : '???') + '\" Gruntfile...';\n  }\n\n  if (options.gruntfile === false) {\n    // Grunt was run as a lib with {gruntfile: false}.\n  } else if (gruntfile && grunt.file.exists(gruntfile)) {\n    grunt.verbose.writeln().write(msg).ok();\n    // Change working directory so that all paths are relative to the\n    // Gruntfile's location (or the --base option, if specified).\n    process.chdir(grunt.option('base') || path.dirname(gruntfile));\n    // Load local tasks, if the file exists.\n    loadTasksMessage('Gruntfile');\n    loadTask(gruntfile);\n  } else if (options.help || allInit) {\n    // Don't complain about missing Gruntfile.\n  } else if (grunt.option('gruntfile')) {\n    // If --config override was specified and it doesn't exist, complain.\n    grunt.log.writeln().write(msg).error();\n    grunt.fatal('Unable to find \"' + gruntfile + '\" Gruntfile.', grunt.fail.code.MISSING_GRUNTFILE);\n  } else if (!grunt.option('help')) {\n    grunt.verbose.writeln().write(msg).error();\n    grunt.log.writelns(\n      'A valid Gruntfile could not be found. Please see the getting ' +\n      'started guide for more information on how to configure grunt: ' +\n      'http://gruntjs.com/getting-started'\n    );\n    grunt.fatal('Unable to find Gruntfile.', grunt.fail.code.MISSING_GRUNTFILE);\n  }\n\n  // Load all user-specified --npm tasks.\n  (grunt.option('npm') || []).map(String).forEach(task.loadNpmTasks);\n  // Load all user-specified --tasks.\n  (grunt.option('tasks') || []).map(String).forEach(task.loadTasks);\n};\n","/home/travis/build/npmtest/node-npmtest-grunt/grunt/lib/grunt/help.js":"'use strict';\n\nvar grunt = require('../grunt');\n\n// Nodejs libs.\nvar path = require('path');\n\n// Set column widths.\nvar col1len = 0;\nexports.initCol1 = function(str) {\n  col1len = Math.max(col1len, str.length);\n};\nexports.initWidths = function() {\n  // Widths for options/tasks table output.\n  exports.widths = [1, col1len, 2, 76 - col1len];\n};\n\n// Render an array in table form.\nexports.table = function(arr) {\n  arr.forEach(function(item) {\n    grunt.log.writetableln(exports.widths, ['', grunt.util._.pad(item[0], col1len), '', item[1]]);\n  });\n};\n\n// Methods to run, in-order.\nexports.queue = [\n  'initOptions',\n  'initTasks',\n  'initWidths',\n  'header',\n  'usage',\n  'options',\n  'optionsFooter',\n  'tasks',\n  'footer',\n];\n\n// Actually display stuff.\nexports.display = function() {\n  exports.queue.forEach(function(name) { exports[name](); });\n};\n\n// Header.\nexports.header = function() {\n  grunt.log.writeln('Grunt: The JavaScript Task Runner (v' + grunt.version + ')');\n};\n\n// Usage info.\nexports.usage = function() {\n  grunt.log.header('Usage');\n  grunt.log.writeln(' ' + path.basename(process.argv[1]) + ' [options] [task [task ...]]');\n};\n\n// Options.\nexports.initOptions = function() {\n  // Build 2-column array for table view.\n  exports._options = Object.keys(grunt.cli.optlist).map(function(long) {\n    var o = grunt.cli.optlist[long];\n    var col1 = '--' + (o.negate ? 'no-' : '') + long + (o.short ? ', -' + o.short : '');\n    exports.initCol1(col1);\n    return [col1, o.info];\n  });\n};\n\nexports.options = function() {\n  grunt.log.header('Options');\n  exports.table(exports._options);\n};\n\nexports.optionsFooter = function() {\n  grunt.log.writeln().writelns(\n    'Options marked with * have methods exposed via the grunt API and should ' +\n    'instead be specified inside the Gruntfile wherever possible.'\n  );\n};\n\n// Tasks.\nexports.initTasks = function() {\n  // Initialize task system so that the tasks can be listed.\n  grunt.task.init([], {help: true});\n\n  // Build object of tasks by info (where they were loaded from).\n  exports._tasks = [];\n  Object.keys(grunt.task._tasks).forEach(function(name) {\n    exports.initCol1(name);\n    var task = grunt.task._tasks[name];\n    exports._tasks.push(task);\n  });\n};\n\nexports.tasks = function() {\n  grunt.log.header('Available tasks');\n  if (exports._tasks.length === 0) {\n    grunt.log.writeln('(no tasks found)');\n  } else {\n    exports.table(exports._tasks.map(function(task) {\n      var info = task.info;\n      if (task.multi) { info += ' *'; }\n      return [task.name, info];\n    }));\n\n    grunt.log.writeln().writelns(\n      'Tasks run in the order specified. Arguments may be passed to tasks that ' +\n      'accept them by using colons, like \"lint:files\". Tasks marked with * are ' +\n      '\"multi tasks\" and will iterate over all sub-targets if no argument is ' +\n      'specified.'\n    );\n  }\n\n  grunt.log.writeln().writelns(\n    'The list of available tasks may change based on tasks directories or ' +\n    'grunt plugins specified in the Gruntfile or via command-line options.'\n  );\n};\n\n// Footer.\nexports.footer = function() {\n  grunt.log.writeln().writeln('For more information, see http://gruntjs.com/');\n};\n","/home/travis/build/npmtest/node-npmtest-grunt/grunt/lib/grunt/cli.js":"'use strict';\n\nvar grunt = require('../grunt');\n\n// External libs.\nvar nopt = require('nopt');\nvar gruntOptions = require('grunt-known-options');\n\n// This is only executed when run via command line.\nvar cli = module.exports = function(options, done) {\n  // CLI-parsed options override any passed-in \"default\" options.\n  if (options) {\n    // For each default option...\n    Object.keys(options).forEach(function(key) {\n      if (!(key in cli.options)) {\n        // If this option doesn't exist in the parsed cli.options, add it in.\n        cli.options[key] = options[key];\n      } else if (cli.optlist[key].type === Array) {\n        // If this option's type is Array, append it to any existing array\n        // (or create a new array).\n        [].push.apply(cli.options[key], options[key]);\n      }\n    });\n  }\n\n  // Run tasks.\n  grunt.tasks(cli.tasks, cli.options, done);\n};\n\n// Default options.\nvar optlist = cli.optlist = gruntOptions;\n\n// Parse `optlist` into a form that nopt can handle.\nvar aliases = {};\nvar known = {};\n\nObject.keys(optlist).forEach(function(key) {\n  var short = optlist[key].short;\n  if (short) {\n    aliases[short] = '--' + key;\n  }\n  known[key] = optlist[key].type;\n});\n\nvar parsed = nopt(known, aliases, process.argv, 2);\ncli.tasks = parsed.argv.remain;\ncli.options = parsed;\ndelete parsed.argv;\n\n// Initialize any Array options that weren't initialized.\nObject.keys(optlist).forEach(function(key) {\n  if (optlist[key].type === Array && !(key in cli.options)) {\n    cli.options[key] = [];\n  }\n});\n"}